Goal: Change storages to Vecs from HashMaps.

ToDo:
0.) Improve API for fetching many Storages (for use in Systems).
	- Requirements:
	- - Ability to request arbitary number of Storages.
	- - Returns zipped iterator over all requestes Storages.

 - Ways:
NEW WAY 3/2/23:
Lots of boilerplate for me but it's worth it.
First, implement many checkout<A, B, C, ..., A>, allowing any number of
generic types from 1..26.
Next, the innovative part: Each of these warehouse fn's returns a custom
struct/type called SystemData, which is implicitly held for the duration of
the system run time, and so holds all the requested storage guards over this
duration. In addition, it implements funcitonality to get a zipped iter over
all the guards it holds. Boom, fantastic. I think this solves my woes.

Old:
	- - Macros: gone down this rabbit hole a bit. Allows for variable number
	  of arguments but collecting them into an iterator at the end has been a
	  challenge.
 A way without macros, which I just had an idea for. Could I store a
collection of req_*_access::<T>() calls where T is already defined, all
in a hashmap? What would the keys be?

I would also need a way to know Keys into this map without having a T. Perhaps
I could impl a static method on the Component trait which returns the typeid
of the Component??? Okay, this is done... so now I can say "Hey World give me
the storage whose type has 'this' id."

Okay so I could now write some fn which accepts a Vec<TypeId> and returns a
zipped iterator over all of the Storages with those types. Nope, can't return
an Iterator without knowing its Item type, which is unknown due to the
variable number of requested storages. Instead, I just need to return a
collection of StorageGuards.
	

1.) Implement functionality for initializing new entities and cleaning up dead
	ones.
Tightly couple Entity generation to Storages.
e.g. When creating an Entity,
First check if there is a dead Entity whose ID you could use. This Entity will
already have an available idx in all Storages, which will all be filled with
"None". If there is no dead entity, then generate a new one equal to any
Storage.length, then increase the size of all Storage Vecs by 1.
Steps:
	- Implement a Storages::length() -> &size method. It's important that this
	  does not require acquiring the Storages Global Mutex.

	- Implement dead entity cleanup: I see three ways, lazy on a per-storage
	  basis, lazy on a warehouse basis, or non-lazy/immediate on a warehouse
	  basis.
	- - Lazy on a per-storage basis:
	Whenever a storage is successfully accessed, it first checks if its length
	is equal to the number of living entities + the number of dead entities.
	If not (which means dead_entities is empty), we need a new slot in the
	vec, which means we need to do a req_write_access() and make it so. If
	we found this state on a read_access, we'd need to drop the read_guard
	and get a write_guard, do the vec lengthening, then drop the write, then
	acquire the read-lock we originally had again. Annoying af and hurts our
	read-access efficiency.

	- - Lazy on an entire warehouse basis, the "garbage collector" way:
	What if I just used a Dead{} component and a MaintainECS system? Downside I
	see already is that this system would need concurrent write access on every
	storage in the warehouse. Could all be done in parallel though... hmm.
	Upside is that it provides an in-library example of how to write a system.

	- - Immediate way:
	When any system finds a dead entity, ...idk fuck it, let's not do it this
	way. It's bad and requires more closures. Complexity cost is too high.

2.) Change StorageGuard API to work with new inner structure.

3.) Define "the way" to write System logic in the lib.rs doctests.

4.) Figure out way to None-ify idx associated with a dead Entity across all
Storages. Right now... seems like making my own garbage collector, but there
may be an easier way: What if I used "Intent-Components"? Maybe "Trigger
Component" is more accurate - a Component with no data but which triggers some
logic only once before it is removed from the Storage.
Anyway, the idea would be to use a System to clean dead entities out of the
storages.
Requirements:
- Run this system first each frame.
- Put dead Entity in Entities::dead_entities() collection.
- When creating new Entities, always pull from dead_entities() if there is one
  avilable rather than making a "new" Entity, which would also increase the
  length of all Storage vecs. 


Why HashMap Storages Don't Work:
A.) Cannot zip storages because HashMap.values() returns the vals in arbitrary order.
Being able to zip arbitrary storages together and iterate through the
resulting zipped iterator is core to "the ECS way". With maps, access is done
through iterating over Entities, which is not correct. The ECS Way is to
iterate over Components, not the things the Components are associated with.
B.) Difficult to implement "MaybeHasComponent" logic, wheras with zipped vecs
the functionality is basically free. Remember, the new InnerStorage type is
Vec<Option<Component>>, so if we find a None, that means that the Entity
associated with this idx of the vec does not have a Component of the type this
Storage holds.
C.) Performance goes brrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr
